
导航
=====				

	三种方式：
		1:react-navigation第三方库(Tab+Nav + 侧栏) （android + ios）
		2:NavigatorIOS + TabBarIOS  (ios)
		3:Navigator组件 不在维护 转移到 方式 1
							
* 导航 react-navigation第三方库
* 该导航都是模拟出来的 具有和原生一样的效果

```
yarn add react-navigation 安装导航库
	
import { StackNavigator,TabNavigator,DrawerNavigator } from "react-navigation"

导航
		1:配置导航路由
			一般的Tab+Nav 导航
				const TabNav = 
					TabNavigator({
				   	 	Home:{screen:StackNavigator({
					        XX:{screen:Page1},  首页
					        OO:{screen:Page2}
				    		})
				   	 	},
				   	 	....
				});
				
			侧栏 + 任意导航
				const Drawer = DrawerNavigator({
					Main:{screen: TabNav},
					Setting:{screen:SettPage}
				})
			
			
		2:注册
			>直接注册
				AppRegistry.registerComponent('MyApp', () => Drawer/TabNav);
			
			>形成组件		
				class APP extends Com{
					render(){
						return (
							<Drawer/TabNav	>
						);
					}
				}
				AppRegistry.registerComponent('MyApp', () => APP);
		3:导航
			1:得到导航对象
 				this.props.navigation
 			2:导航
 				this.props.navigation.navigate("page2")
 				
 		4 导航参数传递:
 			this.props.navigation.navigate("page2",{name:....})
 				
  			let params = this.props.navigation.state.params
  			
  		5:返回
  			this.props.navigation.goBack()
  			this.props.navigation.goBack("home")
  		
API:
	StackNavigator(RouteConfigs, StackNavigatorConfig)
		StackNavigator({
			AAA:{
				screen:指定页面
				getScreen:()=>{
					懒加载
					return  require("..").default; export default class xxxx
				}
				path:"url"
				navigationOptions:{
					也可单独在组件中写
				}// ({navigation})=>{}
			}
			。。。。。
		},{
				initialRouteName:  初始Router
				initialRouteParams: 默认参数
				navigationOptions:
				paths:

				mode: 过度模式
					"card"
					"modal" 重底部出现 但是还是有导航栏
				headerMode：头部模式
					"float"
					"screen"
					"none"没有导航栏
				cardStyle:
				transitionConfig: 自定义过度动画
				onTransitionStart:
				onTransitionEnd:
		})
	
	TabNavigator(RouteConfigs, TabNavigatorConfig)
		TabNavigator({
		...
		},{
			tabBarComponent:ios TabBarBottom /android TabBarTop
			tabBarPosition: 'top/bottom' 
			swipeEnabled:
			animationEnabled:
			lazy: 是否懒加载对于窗口
			tabBarOptions:{//ios 对Tabbar 样式控制
				activeTintColor   激活的label icon 
				activeBackgroundColor  激活的item
				inactiveTintColor 未激活的label icon 
				inactiveBackgroundColor
				showLabel  显示文字label
				style 
				labelStyle
				tabStyle
				.
				//andorid https://reactnavigation.org/docs/navigators/tab
			}
			initialRouteName:设置启动哪个
			order:["chat","Home"]  指定tabs 顺序
			paths:
			backBehavior:
		})
		
	DrawerNavigator({
		见上
	},{
		initialRouteName:初始
		order:[] 排序
		paths
		
		drawerWidth:侧栏宽度
		drawerPosition：left/right 侧栏位置
		contentComponent：侧栏组件  DrawerItems
			props=>{
				return (
					<View>
						<DrawerItems {...props}>
					</View>
				)
			}
		contentOptions:配置侧栏
	})

页面配置
	static navigationOptions  = ({navigation,screenProps,navigationOptions 默认}) => ({
		属性      
	}),或者
	static navigationOptions  =  {
 			title:同时指定上下标题
 				headerTitle:上
 				tabBarLabel:下
 			headerBackTitle:下一界面 返回按钮  默认为title /null无
 			headerTruncatedBackTitle: headerBackTitle没有设置时 显示的返回按钮文字
 			header:自定义导航Bar组件  null 隐藏
 			headerTitle:String  or 组件 
 			headerRight:右侧组件
 				r如何调用组件方法
 				https://segmentfault.com/q/1010000009388102/a-1020000009434621
 			headerLeft:左侧组件
 			headerStyle:头组件样式
 			headerTitleStyle:头组件字样式
 			headerBackTitleStyle:头返回样式
 			headerTintColor:头颜色
 			headerPressColorAndroid：andorid >=5.0
 			gesturesEnabled:手势返回
 			
 			某些在各自导航配置中
 			
 			tabBarIcon：(<Image>)
 			tabBarIcon:(options)=>{
	 			{ tintColor: '#3478f6', focused: true 是否选中}
	 			选择和未选中图标
 				return Image
 			}
 			tabBarLabel:<Text>
 			tabBarLabel:(options)=>{
	 			{ tintColor: '#3478f6', focused: true }
	 			选择和未选中图标
 				return Text
 			}
 		}
 导航对象
 	this.props.navigation
 		{
 			navigate   进行导航
 			state      当前的路由和状态
 			setParams  改变路由参数
 			goBack     返回上个路由
 			dispatch	 send an action to router
 		}
 导航
 	>this.props.navigation.navigate(
 		routeName,
 		参数,
 		action
 	)
 状态
	>this.props.navigation.state===>
		{
			index:当前路由在routes索引
			routes:[
				{
					routeName: 'profile',
					key: 'main0',
					params: { hello: 'world' }
					types
				}
				,
				.....
			]
		}
	>this.props.navigation.setParams({})
	>this.props.navigation.goBack()/(null)/("xxcc")
	
	>this.props.navigation.dispatch(Action)
		给router发送一个动作改变Router行为  
		唯一可以修改Router的API
		this.props.navigation.dispatch(NavigationActions.navigate(...))

Navigation Actions:
	> 导航动作
		NavigationActions.navigate({
			routeName:需要导航的name
			params:导航参数
			action:子动作  不明白干嘛
		})
	> 改变路由
		改变当前状态所在的Nav/Tab路由
		
		NavigationActions.reset({
			index:0,
			actions:[
				0：NavigationActions.navigate({routeName:"xx"}),
				1：NavigationActions.navigate({routeName:"OO"}),
				2：NavigationActions.navigate({routeName:"XXOO"})
			]
			
			"XX"  "OO"  是之前路由中已经定义的
			index:2     表示执行 0 和 1 , 2 动作 
							1 表示执行 0 1
		})
		
		已有的导航栈 "oo" --->"xx" ------->"XXOO"
		执行reset
		现在导航栈 "xx" --->"oo"------->"XXOO", 并且且在激活的是 index
		
	>回退：
		NavigationActions.back() 回退上一级
		NavigationActions.back({ 回退指定
			key：""  ？？？ 
		}) 
	> 改变现有 导航参数
		NavigationActions.setParams({
			params:{}
			key:""  指定哪次导航参数
		})
		.
Deep Linking （https://reactnavigation.org/docs/guides/linking）
		1:设置好导航路由中的path参数
		2:Xcode设置好 URLTypes
			ifentifier: hmmbbf  URl schemes:hmmbbf
		3:AppDelegate
			#import <React/RCTLinkingManager.h>
			- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
			{
	  				return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation];
			}
		4：设置启动注册
			const BB = () => <ZZHRouter uriPrefix={'hmbbf://'}/>
			AppRegistry.registerComponent('MyApp',()=>BB );
		5:启动
			hmmbbf://path/path/参数
			还是提供state params 获取
			
Router：StackNavigator/TabNavigator 来之 Routers
	自定义  Router
		const HomeNavigator = StackNavigator(...)
	得到当前路由	
		let router = HomeNavigator.router  见 Routers
		//设置Action
		const defaultGetStateForAction = HomeNavigator.router.getStateForAction
		router.getStateForAction = (action, state){
			action == NavigationActions{
				type =  NavigationActions.BACK....
				routeName
				params
			}
			state = this.props.navigation.state
			//自定义自己的代码
			 let defaultV = defaultetgetComponentForRouteName(name);
            if(defaultV.power){//需要权限?
                if(!UserManager.isLogin){
                    let _defaultV = defaultetgetComponentForRouteName(ProfileName);
                    
                    let _UserLoginView = (ops)=>{
                      let Login =  new _defaultV(ops);
                        Login.target = name;
                      return Login;
                    };
                    return  _UserLoginView;
                }
            }
            return defaultV;
		}
		
		//设置COmponnet
		class ABCD extends Compoennt{
			static XXX = false;
		}
		const defaultetgetComponentForRouteName = NodeNavigator.router.getComponentForRouteName;
		NodeNavigator.router.getComponentForRouteName = (name)=>{
			name 为你在导航栈中设置的名称
	   	 	let a = defaultetgetComponentForRouteName(name);
			a 为name 对应的组件类
			if(a.XXX){
				return defaultetgetComponentForRouteName("AA");
			} 
		    return a;
		};
		
	api:https://reactnavigation.org/docs/routers/
	
```	

* Routers

```
	StackRouter / TabRouter  
	import { StackRouter } from "react-navigation";
	自定义导航   完全可以替代 StackNavigator。。。
	
	自定义Router
 	 const OneRouter = 	 {
		getStateForAction: (action, state) => ({}),导航Action控制
		getActionForPathAndParams: (path, params) => null,参数设置
  		getPathAndParamsForState: (state) => null,设置State
  		getComponentForState: (state) => MyScreen,通过state 得到组件
   	    getComponentForRouteName: (routeName) => MyScreen,  得到组件对象
   	    getScreenOptions(navigation, screenProps)
   	    getScreenConfig
 	 }
 	 
 	 设置 router属性
 	 class MyNavigatoe extends Component{
	 	 /设置当前router
 	 	static router = OneRouter
 	 	render(){}
 	 }
```
	
	
*  NavigatorIOS + TabBarIOS 实现导航

```
	类似UINavigationController + UITabBarViewController
		class HomeScreen extends Component{
			render(){
				return (
					<NavigatorIOS style={{flex:1}}>
					
					</NavigatorIOS>
				);
			}
		}
		1 > 必须设置initialRoute={  保证初始视图 }
		2> 必须设置flex:1  部分看不到视图 只能看到导航器
		3> 视图起始点为 0,0  在导航器遮挡
		4>使用NavigatorIOS导航的界面都可以使用this.props.navigator 得到导航器进行操作
		
	NavigatorIOS
		barTintColor 导航背景
		initialRoute:{
			component:初始视图 /func
			title：标题
			passProps：{向下传递参数props 传递参数}
			backButtonIcon 
			backButtonTitle
			leftButtonIcon
			leftButtonTitle
			onLeftButtonPress
			
			rightButtonIcon
			rightButtonTitle
			onRightButtonPress
			
			wrapperStyle={}
		}
		
		itemWrapperStyle：导航器组件（一个常见的用途是设置所有页面的背景颜色。）
		navigationBarHidden：bool 导航器隐藏
		
		shadowHidden:阴影 底部1px
		
		tintColor  导航按钮
		titleTextColor
		translucent:是否半透明
		interactivePopGestureEnabled：是否划定返回
		
		
		push(router 和上面一致)
		popN（number）
		pop（
		popToTop（））
		popToRoute（router）
		replaceAtIndex(router,index) 替换栈
		replace（router） 替换当前 并导航
		replacePrevious（router） 替换前一个
		replacePreviousAndPop(router)
		resetTo(router)  替换底部 并导航底部
```

```
数据传递：
	1:导航为页面配置数据
		StackNavigator({
			Home:{
				screen:"HomeView",
				navigationOptions:(navigation)=>{
					return 配置页面数据
				}
			}
		})
	2:页面中配置
		static navigationOptions= ()=>{}//{}
		会覆盖 1 中配置的
	3:为路由器配置参数
	 	 const Navi = StackNavigator({},{})
 		 <Navi screenProps= {}></Navi>
 		在页面中this.props.screenProps 得打该参数
		
```